{"version":3,"file":"browser.js","sources":["src/lib/elements.ts","src/lib/snipTagContent.ts","src/options.ts","src/print/helpers.ts","src/print/doc-helpers.ts","src/print/node-helpers.ts","src/print/index.ts","node_modules/tslib/tslib.es6.mjs","src/lib/getText.ts","src/lib/extractAttributes.ts","src/embed.ts","src/index.ts"],"sourcesContent":["export type TagName = keyof HTMLElementTagNameMap | 'svg';\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = [\n    'area',\n    'base',\n    'br',\n    'col',\n    'embed',\n    'hr',\n    'img',\n    'input',\n    'link',\n    'meta',\n    'param',\n    'source',\n    'track',\n    'wbr',\n];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nexport const blockElements: TagName[] = [\n    'address',\n    'article',\n    'aside',\n    'blockquote',\n    'details',\n    'dialog',\n    'dd',\n    'div',\n    'dl',\n    'dt',\n    'fieldset',\n    'figcaption',\n    'figure',\n    'footer',\n    'form',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'header',\n    'hgroup',\n    'hr',\n    'li',\n    'main',\n    'nav',\n    'ol',\n    'p',\n    'pre',\n    'section',\n    'table',\n    'ul',\n];\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n    // None at the moment\n    // Prettier HTML does not format attributes at all\n    // and to be consistent we leave this array empty for now\n];\n","export const snippedTagContentAttribute = '✂prettier:content✂';\n\nconst scriptRegex =\n    /<!--[^]*?-->|<script((?:\\s+[^=>'\"\\/]+=(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)|\\s+[^=>'\"\\/]+)*\\s*)>([^]*?)<\\/script>/g;\nconst styleRegex =\n    /<!--[^]*?-->|<style((?:\\s+[^=>'\"\\/]+=(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)|\\s+[^=>'\"\\/]+)*\\s*)>([^]*?)<\\/style>/g;\n\nexport function snipScriptAndStyleTagContent(source: string): string {\n    let scriptMatchSpans = getMatchIndexes('script');\n    let styleMatchSpans = getMatchIndexes('style');\n\n    return snipTagContent(\n        snipTagContent(source, 'script', '{}', styleMatchSpans),\n        'style',\n        '',\n        scriptMatchSpans,\n    );\n\n    function getMatchIndexes(tagName: string) {\n        const regex = getRegexp(tagName);\n        const indexes: [number, number][] = [];\n        let match = null;\n        while ((match = regex.exec(source)) != null) {\n            if (source.slice(match.index, match.index + 4) !== '<!--') {\n                indexes.push([match.index, regex.lastIndex]);\n            }\n        }\n        return indexes;\n    }\n\n    function snipTagContent(\n        _source: string,\n        tagName: string,\n        placeholder: string,\n        otherSpans: [number, number][],\n    ) {\n        const regex = getRegexp(tagName);\n        let newScriptMatchSpans = scriptMatchSpans;\n        let newStyleMatchSpans = styleMatchSpans;\n        // Replace valid matches\n        const newSource = _source.replace(regex, (match, attributes, content, index) => {\n            if (match.startsWith('<!--') || withinOtherSpan(index)) {\n                return match;\n            }\n            const encodedContent = Buffer.from(content).toString('base64');\n            const newContent = `<${tagName}${attributes} ${snippedTagContentAttribute}=\"${encodedContent}\">${placeholder}</${tagName}>`;\n\n            // Adjust the spans because the source now has a different content length\n            const lengthDiff = match.length - newContent.length;\n            newScriptMatchSpans = adjustSpans(scriptMatchSpans, newScriptMatchSpans);\n            newStyleMatchSpans = adjustSpans(styleMatchSpans, newStyleMatchSpans);\n            function adjustSpans(\n                oldSpans: [number, number][],\n                newSpans: [number, number][],\n            ): [number, number][] {\n                return oldSpans.map((oldSpan, idx) => {\n                    const newSpan = newSpans[idx];\n                    // Do the check using the old spans because the replace function works\n                    // on the old spans. Replace oldSpans with newSpans afterwards.\n                    if (oldSpan[0] > index) {\n                        // span is after the match -> adjust start and end\n                        return [newSpan[0] - lengthDiff, newSpan[1] - lengthDiff];\n                    } else if (oldSpan[0] === index) {\n                        // span is the match -> adjust end only\n                        return [newSpan[0], newSpan[1] - lengthDiff];\n                    } else {\n                        // span is before the match -> nothing to adjust\n                        return newSpan;\n                    }\n                });\n            }\n\n            return newContent;\n        });\n\n        // Now that the replacement function ran, we can adjust the spans for the next run\n        scriptMatchSpans = newScriptMatchSpans;\n        styleMatchSpans = newStyleMatchSpans;\n\n        return newSource;\n\n        function withinOtherSpan(idx: number) {\n            return otherSpans.some((otherSpan) => idx > otherSpan[0] && idx < otherSpan[1]);\n        }\n    }\n\n    function getRegexp(tagName: string) {\n        return tagName === 'script' ? scriptRegex : styleRegex;\n    }\n}\n\nexport function hasSnippedContent(text: string) {\n    return text.includes(snippedTagContentAttribute);\n}\n\nconst regex = /(<\\w+.*?)\\s*✂prettier:content✂=\"(.*?)\">.*?(?=<\\/)/gi;\n\nexport function unsnipContent(text: string): string {\n    return text.replace(regex, (_, start, encodedContent) => {\n        const content = Buffer.from(encodedContent, 'base64').toString('utf8');\n        return `${start}>${content}`;\n    });\n}\n","import { ParserOptions as PrettierParserOptions, SupportOption } from 'prettier';\nimport { SortOrder, PluginConfig } from '..';\n\nexport interface ParserOptions<T = any> extends PrettierParserOptions<T>, Partial<PluginConfig> {}\n\nfunction makeChoice(choice: string) {\n    return { value: choice, description: choice };\n}\n\nexport const options: Record<keyof PluginConfig, SupportOption> = {\n    svelteSortOrder: {\n        category: 'Svelte',\n        type: 'choice',\n        default: 'options-scripts-markup-styles',\n        description: 'Sort order for scripts, markup, and styles',\n        choices: [\n            makeChoice('options-scripts-markup-styles'),\n            makeChoice('options-scripts-styles-markup'),\n            makeChoice('options-markup-styles-scripts'),\n            makeChoice('options-markup-scripts-styles'),\n            makeChoice('options-styles-markup-scripts'),\n            makeChoice('options-styles-scripts-markup'),\n            makeChoice('scripts-options-markup-styles'),\n            makeChoice('scripts-options-styles-markup'),\n            makeChoice('markup-options-styles-scripts'),\n            makeChoice('markup-options-scripts-styles'),\n            makeChoice('styles-options-markup-scripts'),\n            makeChoice('styles-options-scripts-markup'),\n            makeChoice('scripts-markup-options-styles'),\n            makeChoice('scripts-styles-options-markup'),\n            makeChoice('markup-styles-options-scripts'),\n            makeChoice('markup-scripts-options-styles'),\n            makeChoice('styles-markup-options-scripts'),\n            makeChoice('styles-scripts-options-markup'),\n            makeChoice('scripts-markup-styles-options'),\n            makeChoice('scripts-styles-markup-options'),\n            makeChoice('markup-styles-scripts-options'),\n            makeChoice('markup-scripts-styles-options'),\n            makeChoice('styles-markup-scripts-options'),\n            makeChoice('styles-scripts-markup-options'),\n            makeChoice('none'),\n        ],\n    },\n    svelteStrictMode: {\n        category: 'Svelte',\n        type: 'boolean',\n        default: false,\n        description: 'More strict HTML syntax: Quotes in attributes, no self-closing DOM tags',\n    },\n    svelteBracketNewLine: {\n        category: 'Svelte',\n        type: 'boolean',\n        description: 'Put the `>` of a multiline element on a new line',\n        deprecated: '2.5.0',\n    },\n    svelteAllowShorthand: {\n        category: 'Svelte',\n        type: 'boolean',\n        default: true,\n        description:\n            'Option to enable/disable component attribute shorthand if attribute name and expressions are same',\n    },\n    svelteIndentScriptAndStyle: {\n        category: 'Svelte',\n        type: 'boolean',\n        default: true,\n        description:\n            'Whether or not to indent the code inside <script> and <style> tags in Svelte files',\n    },\n};\n\nexport type SortOrderPart = 'scripts' | 'markup' | 'styles' | 'options';\n\nconst sortOrderSeparator = '-';\n\nexport function parseSortOrder(\n    sortOrder: SortOrder = 'options-scripts-markup-styles',\n): SortOrderPart[] {\n    if (sortOrder === 'none') {\n        return [];\n    }\n\n    const order = sortOrder.split(sortOrderSeparator) as SortOrderPart[];\n    // For backwards compatibility: Add options to beginning if not present\n    if (!order.includes('options')) {\n        throw new Error('svelteSortOrder is missing option `options`');\n    }\n    return order;\n}\n\nexport function isBracketSameLine(options: ParserOptions): boolean {\n    return options.svelteBracketNewLine != null\n        ? !options.svelteBracketNewLine\n        : options.bracketSameLine != null\n        ? options.bracketSameLine\n        : false;\n}\n","import { Doc, doc, FastPath } from 'prettier';\nimport { PrintFn } from '.';\nimport { formattableAttributes } from '../lib/elements';\nimport { snippedTagContentAttribute } from '../lib/snipTagContent';\nimport {\n    ASTNode,\n    AttributeNode,\n    BodyNode,\n    DocumentNode,\n    ElementNode,\n    HeadNode,\n    InlineComponentNode,\n    Node,\n    OptionsNode,\n    ScriptNode,\n    SlotNode,\n    SlotTemplateNode,\n    StyleNode,\n    TitleNode,\n    WindowNode\n} from './nodes';\nimport { ParserOptions } from '../options';\n\n/**\n * Determines whether or not given node\n * is the root of the Svelte AST.\n */\nexport function isASTNode(n: any): n is ASTNode {\n    return n && n.__isRoot;\n}\n\nexport function isPreTagContent(path: FastPath): boolean {\n    const stack = path.stack as Node[];\n\n    return stack.some(\n        (node) =>\n            (node.type === 'Element' && node.name.toLowerCase() === 'pre') ||\n            (node.type === 'Attribute' && !formattableAttributes.includes(node.name)),\n    );\n}\n\nexport function flatten<T>(arrays: T[][]): T[] {\n    return ([] as T[]).concat.apply([], arrays);\n}\n\nexport function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\n    for (let i = items.length - 1; i >= 0; i--) {\n        if (isMatch(items[i], i)) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nexport function replaceEndOfLineWith(text: string, replacement: Doc) {\n    const parts: Doc[] = [];\n    for (const part of text.split('\\n')) {\n        if (parts.length > 0) {\n            parts.push(replacement);\n        }\n        if (part.endsWith('\\r')) {\n            parts.push(part.slice(0, -1));\n        } else {\n            parts.push(part);\n        }\n    }\n    return parts;\n}\n\nexport function getAttributeLine(\n    node:\n        | ElementNode\n        | InlineComponentNode\n        | SlotNode\n        | WindowNode\n        | HeadNode\n        | TitleNode\n        | StyleNode\n        | ScriptNode\n        | BodyNode\n        | DocumentNode\n        | OptionsNode\n        | SlotTemplateNode,\n    options: ParserOptions,\n) {\n    const { hardline, line } = doc.builders;\n    const hasThisBinding =\n        (node.type === 'InlineComponent' && !!node.expression) ||\n        (node.type === 'Element' && !!node.tag);\n\n    const attributes = (node.attributes as Array<AttributeNode>).filter(\n        (attribute) => attribute.name !== snippedTagContentAttribute,\n    );\n    return options.singleAttributePerLine &&\n        (attributes.length > 1 || (attributes.length && hasThisBinding))\n        ? hardline\n        : line;\n}\n\nexport function printWithPrependedAttributeLine(\n    node:\n        | ElementNode\n        | InlineComponentNode\n        | SlotNode\n        | WindowNode\n        | HeadNode\n        | TitleNode\n        | StyleNode\n        | ScriptNode\n        | BodyNode\n        | DocumentNode\n        | OptionsNode\n        | SlotTemplateNode,\n    options: ParserOptions,\n    print: PrintFn,\n): PrintFn {\n    return (path) =>\n        path.getNode().name !== snippedTagContentAttribute\n            ? [getAttributeLine(node, options), path.call(print)]\n            : '';\n}\n","import { Doc, doc } from 'prettier';\nimport { findLastIndex } from './helpers';\n\n/**\n * Check if doc is a hardline.\n * We can't just rely on a simple equality check because the doc could be created with another\n * runtime version of prettier than what we import, making a reference check fail.\n */\nexport function isHardline(docToCheck: Doc): boolean {\n    return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\n}\n\n/**\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\n */\nfunction deepEqual(x: any, y: any): boolean {\n    if (x === y) {\n        return true;\n    } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\n        if (Object.keys(x).length != Object.keys(y).length) return false;\n\n        for (var prop in x) {\n            if (y.hasOwnProperty(prop)) {\n                if (!deepEqual(x[prop], y[prop])) return false;\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\n    return typeof doc === 'object' && doc !== null;\n}\n\nexport function isLine(docToCheck: Doc): boolean {\n    return (\n        isHardline(docToCheck) ||\n        (isDocCommand(docToCheck) && docToCheck.type === 'line') ||\n        (Array.isArray(docToCheck) && docToCheck.every(isLine))\n    );\n}\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\nexport function isEmptyDoc(doc: Doc): boolean {\n    if (typeof doc === 'string') {\n        return doc.length === 0;\n    }\n\n    if (isDocCommand(doc) && doc.type === 'line') {\n        return !doc.keepIfLonely;\n    }\n\n    if (Array.isArray(doc)) {\n        return doc.length === 0;\n    }\n\n    const { contents } = doc as { contents?: Doc };\n\n    if (contents) {\n        return isEmptyDoc(contents);\n    }\n\n    const { parts } = doc as { parts?: Doc[] };\n\n    if (parts) {\n        return isEmptyGroup(parts);\n    }\n\n    return false;\n}\n\nexport function isEmptyGroup(group: Doc[]): boolean {\n    return !group.find((doc) => !isEmptyDoc(doc));\n}\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\nexport function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n    trimLeft(docs, isWhitespace);\n    trimRight(docs, isWhitespace);\n\n    return docs;\n}\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs before the first whitespace, they are removed, too.\n */\nexport function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n    let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\n\n    if (firstNonWhitespace < 0 && group.length) {\n        firstNonWhitespace = group.length;\n    }\n\n    if (firstNonWhitespace > 0) {\n        const removed = group.splice(0, firstNonWhitespace);\n        if (removed.every(isEmptyDoc)) {\n            return trimLeft(group, isWhitespace);\n        }\n    } else {\n        const parts = getParts(group[0]);\n\n        if (parts) {\n            return trimLeft(parts, isWhitespace);\n        }\n    }\n}\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs after the last whitespace, they are removed, too.\n */\nexport function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n    let lastNonWhitespace = group.length\n        ? findLastIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc), group)\n        : 0;\n\n    if (lastNonWhitespace < group.length - 1) {\n        const removed = group.splice(lastNonWhitespace + 1);\n        if (removed.every(isEmptyDoc)) {\n            return trimRight(group, isWhitespace);\n        }\n    } else {\n        const parts = getParts(group[group.length - 1]);\n\n        if (parts) {\n            return trimRight(parts, isWhitespace);\n        }\n    }\n}\n\nfunction getParts(doc: Doc): Doc[] | undefined {\n    if (typeof doc === 'object') {\n        if (Array.isArray(doc)) {\n            return doc;\n        }\n        if (doc.type === 'fill') {\n            return doc.parts;\n        }\n        if (doc.type === 'group') {\n            return getParts(doc.contents);\n        }\n    }\n}\n\n/**\n * `(foo = bar)` => `foo = bar`\n */\nexport function removeParentheses(doc: Doc): Doc {\n    return trim([doc], (_doc: Doc) => _doc === '(' || _doc === ')')[0];\n}\n","import {\n    Node,\n    ElementNode,\n    TextNode,\n    AttributeNode,\n    MustacheTagNode,\n    AttributeShorthandNode,\n    HeadNode,\n    InlineComponentNode,\n    SlotNode,\n    TitleNode,\n    WindowNode,\n    IfBlockNode,\n    AwaitBlockNode,\n    CatchBlockNode,\n    EachBlockNode,\n    ElseBlockNode,\n    KeyBlockNode,\n    PendingBlockNode,\n    ThenBlockNode,\n    CommentNode,\n    SlotTemplateNode,\n    StyleDirectiveNode,\n    ASTNode,\n    CommentInfo,\n} from './nodes';\nimport { blockElements, TagName } from '../lib/elements';\nimport { FastPath } from 'prettier';\nimport { findLastIndex, isASTNode, isPreTagContent } from './helpers';\nimport { ParserOptions, isBracketSameLine } from '../options';\n\nconst unsupportedLanguages = ['coffee', 'coffeescript', 'styl', 'stylus', 'sass'];\n\nexport function isInlineElement(path: FastPath, options: ParserOptions, node: Node) {\n    return (\n        node && node.type === 'Element' && !isBlockElement(node, options) && !isPreTagContent(path)\n    );\n}\n\nexport function isBlockElement(node: Node, options: ParserOptions): node is ElementNode {\n    return (\n        node &&\n        node.type === 'Element' &&\n        options.htmlWhitespaceSensitivity !== 'strict' &&\n        (options.htmlWhitespaceSensitivity === 'ignore' ||\n            blockElements.includes(node.name as TagName))\n    );\n}\n\nexport function isSvelteBlock(\n    node: Node,\n): node is\n    | IfBlockNode\n    | AwaitBlockNode\n    | CatchBlockNode\n    | EachBlockNode\n    | ElseBlockNode\n    | KeyBlockNode\n    | PendingBlockNode\n    | ThenBlockNode {\n    return [\n        'IfBlock',\n        'SnippetBlock',\n        'AwaitBlock',\n        'CatchBlock',\n        'EachBlock',\n        'ElseBlock',\n        'KeyBlock',\n        'PendingBlock',\n        'ThenBlock',\n    ].includes(node.type);\n}\n\nexport function isNodeWithChildren(node: Node): node is Node & { children: Node[] } {\n    return (node as any).children;\n}\n\nexport function getChildren(node: Node): Node[] {\n    return isNodeWithChildren(node) ? node.children : [];\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: FastPath): Node[] {\n    let parent: Node = path.getParentNode();\n\n    if (isASTNode(parent)) {\n        parent = parent.html;\n    }\n\n    return getChildren(parent);\n}\n\n/**\n * Returns the previous sibling node.\n */\nexport function getPreviousNode(path: FastPath): Node | undefined {\n    const node: Node = path.getNode();\n    return getSiblings(path).find((child) => child.end === node.start);\n}\n\n/**\n * Returns the next sibling node.\n */\nexport function getNextNode(path: FastPath, node: Node = path.getNode()): Node | undefined {\n    return getSiblings(path).find((child) => child.start === node.end);\n}\n\n/**\n * Returns the comment that is above the current node.\n */\nexport function getLeadingComment(path: FastPath): CommentNode | undefined {\n    const siblings = getSiblings(path);\n\n    let node: Node = path.getNode();\n    let prev: Node | undefined = siblings.find((child) => child.end === node.start);\n    while (prev) {\n        if (\n            prev.type === 'Comment' &&\n            !isIgnoreStartDirective(prev) &&\n            !isIgnoreEndDirective(prev)\n        ) {\n            return prev;\n        } else if (isEmptyTextNode(prev)) {\n            node = prev;\n            prev = siblings.find((child) => child.end === node.start);\n        } else {\n            return undefined;\n        }\n    }\n}\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\nexport function doesEmbedStartAfterNode(node: Node, path: FastPath, siblings = getSiblings(path)) {\n    // If node is not at the top level of html, an embed cannot start after it,\n    // because embeds are only at the top level\n    if (!isNodeTopLevelHTML(node, path)) {\n        return false;\n    }\n\n    const position = node.end;\n    const root = path.stack[0];\n\n    const embeds = [root.css, root.html, root.instance, root.js, root.module] as Node[];\n\n    const nextNode = siblings[siblings.indexOf(node) + 1];\n    return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\n}\n\nexport function isNodeTopLevelHTML(node: Node, path: FastPath): boolean {\n    const root = path.stack[0];\n    return !!root.html && !!root.html.children && root.html.children.includes(node);\n}\n\nexport function isEmptyTextNode(node: Node | undefined): node is TextNode {\n    return !!node && node.type === 'Text' && getUnencodedText(node).trim() === '';\n}\n\nexport function isIgnoreDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore';\n}\n\nexport function isIgnoreStartDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-start';\n}\n\nexport function isIgnoreEndDirective(node: Node | undefined | null): boolean {\n    return !!node && node.type === 'Comment' && node.data.trim() === 'prettier-ignore-end';\n}\n\nexport function printRaw(\n    node:\n        | ElementNode\n        | InlineComponentNode\n        | SlotNode\n        | WindowNode\n        | HeadNode\n        | TitleNode\n        | SlotTemplateNode,\n    originalText: string,\n    stripLeadingAndTrailingNewline: boolean = false,\n): string {\n    if (node.children.length === 0) {\n        return '';\n    }\n\n    const firstChild = node.children[0];\n    const lastChild = node.children[node.children.length - 1];\n\n    let raw = originalText.substring(firstChild.start, lastChild.end);\n\n    if (!stripLeadingAndTrailingNewline) {\n        return raw;\n    }\n\n    if (startsWithLinebreak(raw)) {\n        raw = raw.substring(raw.indexOf('\\n') + 1);\n    }\n    if (endsWithLinebreak(raw)) {\n        raw = raw.substring(0, raw.lastIndexOf('\\n'));\n        if (raw.charAt(raw.length - 1) === '\\r') {\n            raw = raw.substring(0, raw.length - 1);\n        }\n    }\n\n    return raw;\n}\n\nfunction isTextNode(node: Node): node is TextNode {\n    return node.type === 'Text';\n}\n\nfunction getAttributeValue(attributeName: string, node: Node) {\n    const attributes = ((node as ElementNode).attributes ?? []) as AttributeNode[];\n\n    const langAttribute = attributes.find((attribute) => attribute.name === attributeName);\n\n    return langAttribute && langAttribute.value;\n}\n\nexport function getAttributeTextValue(attributeName: string, node: Node): string | null {\n    const value = getAttributeValue(attributeName, node);\n\n    if (value != null && typeof value === 'object') {\n        const textValue = value.find(isTextNode);\n\n        if (textValue) {\n            return textValue.data;\n        }\n    }\n\n    return null;\n}\n\nfunction getLangAttribute(node: Node): string | null {\n    const value = getAttributeTextValue('lang', node) || getAttributeTextValue('type', node);\n\n    if (value != null) {\n        return value.replace(/^text\\//, '');\n    } else {\n        return null;\n    }\n}\n\n/**\n * Checks whether the node contains a `lang` or `type` attribute with a value corresponding to\n * a language we cannot format. This might for example be `<template lang=\"pug\">`.\n * If the node does not contain a `lang` attribute, the result is true.\n */\nexport function isNodeSupportedLanguage(node: Node) {\n    const lang = getLangAttribute(node);\n\n    return !(lang && unsupportedLanguages.includes(lang));\n}\n\n/**\n * Checks whether the node contains a `lang` or `type` attribute which indicates that\n * the script contents are written in TypeScript. Note that the absence of the tag\n * does not mean it's not TypeScript, because the user could have set the default\n * to TypeScript in his settings.\n */\nexport function isTypeScript(node: Node) {\n    const lang = getLangAttribute(node) || '';\n    return ['typescript', 'ts'].includes(lang);\n}\n\nexport function isLess(node: Node) {\n    const lang = getLangAttribute(node) || '';\n    return ['less'].includes(lang);\n}\n\nexport function isScss(node: Node) {\n    const lang = getLangAttribute(node) || '';\n    return ['sass', 'scss'].includes(lang);\n}\n\nexport function isPugTemplate(node: Node): boolean {\n    return node.type === 'Element' && node.name === 'template' && getLangAttribute(node) === 'pug';\n}\n\nexport function isLoneMustacheTag(node: true | Node[]): node is [MustacheTagNode] {\n    return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\nexport function isAttributeShorthand(node: true | Node[]): node is [AttributeShorthandNode] {\n    return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n}\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode | StyleDirectiveNode): boolean {\n    if (isAttributeShorthand(node.value)) {\n        return true;\n    }\n\n    if (isLoneMustacheTag(node.value)) {\n        const expression = node.value[0].expression;\n        return expression.type === 'Identifier' && expression.name === node.name;\n    }\n\n    return false;\n}\n\nexport function getUnencodedText(node: TextNode) {\n    // `raw` will contain HTML entities in unencoded form\n    return node.raw || node.data;\n}\n\nexport function isTextNodeStartingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\n    return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\n    return new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\nexport function isTextNodeEndingWithLinebreak(node: Node, nrLines = 1): node is TextNode {\n    return node.type === 'Text' && endsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\n    return new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\n    return node.type === 'Text' && /^\\s/.test(getUnencodedText(node));\n}\n\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\n    return node.type === 'Text' && /\\s$/.test(getUnencodedText(node));\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n    node.raw = node.raw && node.raw.trimRight();\n    node.data = node.data && node.data.trimRight();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n    node.raw = node.raw && node.raw.trimLeft();\n    node.data = node.data && node.data.trimLeft();\n}\n\n/**\n * Remove all leading whitespace up until the first non-empty text node,\n * and all trailing whitespace from the last non-empty text node onwards.\n */\nexport function trimChildren(children: Node[], path: FastPath): void {\n    let firstNonEmptyNode = children.findIndex(\n        (n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path),\n    );\n    firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\n\n    let lastNonEmptyNode = findLastIndex((n, idx) => {\n        // Last node is ok to end at the start of an embedded region,\n        // if it's not a comment (which should stick to the region)\n        return (\n            !isEmptyTextNode(n) &&\n            ((idx === children.length - 1 && n.type !== 'Comment') ||\n                !doesEmbedStartAfterNode(n, path))\n        );\n    }, children);\n    lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\n\n    for (let i = 0; i <= firstNonEmptyNode; i++) {\n        const n = children[i];\n        if (n.type === 'Text') {\n            trimTextNodeLeft(n);\n        }\n    }\n\n    for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\n        const n = children[i];\n        if (n.type === 'Text') {\n            trimTextNodeRight(n);\n        }\n    }\n}\n\n/**\n * Check if given node's start tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(\n    node: Node,\n    isSupportedLanguage: boolean,\n    options: ParserOptions,\n): boolean {\n    if (!isSupportedLanguage) {\n        return true;\n    }\n\n    if (isBlockElement(node, options)) {\n        return false;\n    }\n\n    if (!isNodeWithChildren(node)) {\n        return false;\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return true;\n    }\n\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\n        return false;\n    }\n\n    const firstChild = children[0];\n    return !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(\n    node: Node,\n    isSupportedLanguage: boolean,\n    options: ParserOptions,\n): boolean {\n    if (!isSupportedLanguage) {\n        return true;\n    }\n\n    if (isBlockElement(node, options)) {\n        return false;\n    }\n\n    if (!isNodeWithChildren(node)) {\n        return false;\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return true;\n    }\n\n    if (options.htmlWhitespaceSensitivity === 'ignore') {\n        return false;\n    }\n\n    const lastChild = children[children.length - 1];\n    return !isTextNodeEndingWithWhitespace(lastChild);\n}\n\n/**\n * Check for a svelte block if there's whitespace at the start and if it's a space or a line.\n */\nexport function checkWhitespaceAtStartOfSvelteBlock(\n    node: Node,\n    options: ParserOptions,\n): 'none' | 'space' | 'line' {\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\n        return 'none';\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return 'none';\n    }\n\n    const firstChild = children[0];\n\n    if (isTextNodeStartingWithLinebreak(firstChild)) {\n        return 'line';\n    } else if (isTextNodeStartingWithWhitespace(firstChild)) {\n        return 'space';\n    }\n\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\n    // the block's starting end and its first child.\n    const parentOpeningEnd = options.originalText.lastIndexOf('}', firstChild.start);\n    if (parentOpeningEnd > 0 && firstChild.start > parentOpeningEnd + 1) {\n        const textBetween = options.originalText.substring(parentOpeningEnd + 1, firstChild.start);\n        if (textBetween.trim() === '') {\n            return startsWithLinebreak(textBetween) ? 'line' : 'space';\n        }\n    }\n\n    return 'none';\n}\n\n/**\n * Check for a svelte block if there's whitespace at the end and if it's a space or a line.\n */\nexport function checkWhitespaceAtEndOfSvelteBlock(\n    node: Node,\n    options: ParserOptions,\n): 'none' | 'space' | 'line' {\n    if (!isSvelteBlock(node) || !isNodeWithChildren(node)) {\n        return 'none';\n    }\n\n    const children: Node[] = node.children;\n    if (children.length === 0) {\n        return 'none';\n    }\n\n    const lastChild = children[children.length - 1];\n    if (isTextNodeEndingWithLinebreak(lastChild)) {\n        return 'line';\n    } else if (isTextNodeEndingWithWhitespace(lastChild)) {\n        return 'space';\n    }\n\n    // This extra check is necessary because the Svelte AST might swallow whitespace between\n    // the last child and the block's ending start.\n    const parentClosingStart = options.originalText.indexOf('{', lastChild.end);\n    if (parentClosingStart > 0 && lastChild.end < parentClosingStart) {\n        const textBetween = options.originalText.substring(lastChild.end, parentClosingStart);\n        if (textBetween.trim() === '') {\n            return endsWithLinebreak(textBetween) ? 'line' : 'space';\n        }\n    }\n\n    return 'none';\n}\n\nexport function isInsideQuotedAttribute(path: FastPath, options: ParserOptions): boolean {\n    const stack = path.stack as Node[];\n\n    return stack.some(\n        (node) =>\n            node.type === 'Attribute' &&\n            (!isLoneMustacheTag(node.value) || options.svelteStrictMode),\n    );\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(\n    node: Node,\n    path: FastPath,\n    options: ParserOptions,\n): boolean {\n    return (\n        isBracketSameLine(options) &&\n        (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options))\n    );\n}\n\n/**\n * Return true if given node does not hug the next node, meaning there's whitespace\n * or the end of the doc afterwards.\n */\nfunction hugsStartOfNextNode(node: Node, options: ParserOptions): boolean {\n    if (node.end === options.originalText.length) {\n        // end of document\n        return false;\n    }\n\n    return !options.originalText.substring(node.end).match(/^\\s/);\n}\n\nfunction isLastChildWithinParentBlockElement(path: FastPath, options: ParserOptions): boolean {\n    const parent = path.getParentNode() as Node | undefined;\n    if (!parent || !isBlockElement(parent, options)) {\n        return false;\n    }\n\n    const children = getChildren(parent);\n    const lastChild = children[children.length - 1];\n    return lastChild === path.getNode();\n}\n\nexport function assignCommentsToNodes(ast: ASTNode) {\n    if (ast.module) {\n        ast.module.comments = removeAndGetLeadingComments(ast, ast.module);\n    }\n    if (ast.instance) {\n        ast.instance.comments = removeAndGetLeadingComments(ast, ast.instance);\n    }\n    if (ast.css) {\n        ast.css.comments = removeAndGetLeadingComments(ast, ast.css);\n    }\n}\n\n/**\n * Returns the comments that are above the current node and deletes them from the html ast.\n */\nfunction removeAndGetLeadingComments(ast: ASTNode, current: Node): CommentInfo[] {\n    const siblings = getChildren(ast.html);\n    const comments: CommentNode[] = [];\n    const newlines: TextNode[] = [];\n\n    if (!siblings.length) {\n        return [];\n    }\n\n    let node: Node = current;\n    let prev: Node | undefined = siblings.find((child) => child.end === node.start);\n    while (prev) {\n        if (\n            prev.type === 'Comment' &&\n            !isIgnoreStartDirective(prev) &&\n            !isIgnoreEndDirective(prev)\n        ) {\n            comments.push(prev);\n            if (comments.length !== newlines.length) {\n                newlines.push({ type: 'Text', data: '', raw: '', start: -1, end: -1 });\n            }\n        } else if (isEmptyTextNode(prev)) {\n            newlines.push(prev);\n        } else {\n            break;\n        }\n\n        node = prev;\n        prev = siblings.find((child) => child.end === node.start);\n    }\n\n    newlines.length = comments.length; // could be one more if first comment is preceeded by empty text node\n\n    for (const comment of comments) {\n        siblings.splice(siblings.indexOf(comment), 1);\n    }\n\n    for (const text of newlines) {\n        siblings.splice(siblings.indexOf(text), 1);\n    }\n\n    return comments\n        .map((comment, i) => ({\n            comment,\n            emptyLineAfter: getUnencodedText(newlines[i]).split('\\n').length > 2,\n        }))\n        .reverse();\n}\n","import { Doc, doc, FastPath } from 'prettier';\nimport { formattableAttributes, selfClosingTags } from '../lib/elements';\nimport { hasSnippedContent, unsnipContent } from '../lib/snipTagContent';\nimport { isBracketSameLine, ParserOptions, parseSortOrder, SortOrderPart } from '../options';\nimport { isEmptyDoc, isLine, trim, trimRight } from './doc-helpers';\nimport {\n    flatten,\n    getAttributeLine,\n    isASTNode,\n    isPreTagContent,\n    printWithPrependedAttributeLine,\n    replaceEndOfLineWith,\n} from './helpers';\nimport {\n    canOmitSoftlineBeforeClosingTag,\n    checkWhitespaceAtEndOfSvelteBlock,\n    checkWhitespaceAtStartOfSvelteBlock,\n    doesEmbedStartAfterNode,\n    endsWithLinebreak,\n    getChildren,\n    getNextNode,\n    getUnencodedText,\n    isBlockElement,\n    isEmptyTextNode,\n    isIgnoreDirective,\n    isIgnoreEndDirective,\n    isIgnoreStartDirective,\n    isInlineElement,\n    isInsideQuotedAttribute,\n    isLoneMustacheTag,\n    isNodeSupportedLanguage,\n    isNodeTopLevelHTML,\n    isOrCanBeConvertedToShorthand,\n    isTextNodeEndingWithLinebreak,\n    isTextNodeEndingWithWhitespace,\n    isTextNodeStartingWithLinebreak,\n    isTextNodeStartingWithWhitespace,\n    printRaw,\n    shouldHugEnd,\n    shouldHugStart,\n    startsWithLinebreak,\n    trimChildren,\n    trimTextNodeLeft,\n    trimTextNodeRight,\n} from './node-helpers';\nimport {\n    ASTNode,\n    AttributeNode,\n    CommentInfo,\n    CommentNode,\n    IfBlockNode,\n    Node,\n    OptionsNode,\n    StyleDirectiveNode,\n    TextNode,\n} from './nodes';\n\nconst { join, line, group, indent, dedent, softline, hardline, fill, breakParent, literalline } =\n    doc.builders;\n\nexport type PrintFn = (path: FastPath) => Doc;\n\ndeclare module 'prettier' {\n    export namespace doc {\n        namespace builders {\n            interface Line {\n                keepIfLonely?: boolean;\n            }\n        }\n    }\n}\n\nexport function hasPragma(text: string) {\n    return /^\\s*<!--\\s*@(format|prettier)\\W/.test(text);\n}\n\nlet ignoreNext = false;\nlet ignoreRange = false;\nlet svelteOptionsDoc: Doc | undefined;\n\nexport function print(path: FastPath, options: ParserOptions, print: PrintFn): Doc {\n    const bracketSameLine = isBracketSameLine(options);\n\n    const n = path.getValue();\n    if (!n) {\n        return '';\n    }\n\n    if (isASTNode(n)) {\n        return printTopLevelParts(n, options, path, print);\n    }\n\n    const [open, close] = options.svelteStrictMode ? ['\"{', '}\"'] : ['{', '}'];\n    const printJsExpression = () => [open, printJS(path, print, 'expression'), close];\n    const node = n as Node;\n\n    if (\n        (ignoreNext || (ignoreRange && !isIgnoreEndDirective(node))) &&\n        (node.type !== 'Text' || !isEmptyTextNode(node))\n    ) {\n        if (ignoreNext) {\n            ignoreNext = false;\n        }\n        return flatten(\n            options.originalText\n                .slice(options.locStart(node), options.locEnd(node))\n                .split('\\n')\n                .map((o, i) => (i == 0 ? [o] : [literalline, o])),\n        );\n    }\n\n    switch (node.type) {\n        case 'Fragment':\n            const children = node.children;\n\n            if (children.length === 0 || children.every(isEmptyTextNode)) {\n                return '';\n            }\n            if (!isPreTagContent(path)) {\n                trimChildren(node.children, path);\n                const output = trim(\n                    [printChildren(path, print, options)],\n                    (n) =>\n                        isLine(n) ||\n                        (typeof n === 'string' && n.trim() === '') ||\n                        // Because printChildren may append this at the end and\n                        // may hide other lines before it\n                        n === breakParent,\n                );\n                if (output.every((doc) => isEmptyDoc(doc))) {\n                    return '';\n                }\n                return group([...output, hardline]);\n            } else {\n                return group(path.map(print, 'children'));\n            }\n        case 'Text':\n            if (!isPreTagContent(path)) {\n                if (isEmptyTextNode(node)) {\n                    const hasWhiteSpace =\n                        getUnencodedText(node).trim().length < getUnencodedText(node).length;\n                    const hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n                    const hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\n                    if (hasTwoOrMoreNewlines) {\n                        return [hardline, hardline];\n                    }\n                    if (hasOneOrMoreNewlines) {\n                        return hardline;\n                    }\n                    if (hasWhiteSpace) {\n                        return line;\n                    }\n                    return '';\n                }\n\n                /**\n                 * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n                 * each \"word\") is joined by a single `line`, which will be rendered as a single space\n                 * until this node's current line is out of room, at which `fill` will break at the\n                 * most convenient instance of `line`.\n                 */\n                return fill(splitTextToDocs(node));\n            } else {\n                let rawText = getUnencodedText(node);\n                const parent = path.getParentNode();\n                if (parent.type === 'Attribute') {\n                    // Direct child of attribute value -> add literallines at end of lines\n                    // so that other things don't break in unexpected places\n                    if (parent.name === 'class' && path.getParentNode(1).type === 'Element') {\n                        // Special treatment for class attribute on html elements. Prettier\n                        // will force everything into one line, we deviate from that and preserve lines.\n                        rawText = rawText.replace(\n                            /([^ \\t\\n])(([ \\t]+$)|([ \\t]+(\\r?\\n))|[ \\t]+)/g,\n                            // Remove trailing whitespace in lines with non-whitespace characters\n                            // except at the end of the string\n                            (\n                                match,\n                                characterBeforeWhitespace,\n                                _,\n                                isEndOfString,\n                                isEndOfLine,\n                                endOfLine,\n                            ) =>\n                                isEndOfString\n                                    ? match\n                                    : characterBeforeWhitespace + (isEndOfLine ? endOfLine : ' '),\n                        );\n                        // Shrink trailing whitespace in case it's followed by a mustache tag\n                        // and remove it completely if it's at the end of the string, but not\n                        // if it's on its own line\n                        rawText = rawText.replace(\n                            /([^ \\t\\n])[ \\t]+$/,\n                            parent.value.indexOf(node) === parent.value.length - 1 ? '$1' : '$1 ',\n                        );\n                    }\n                    return replaceEndOfLineWith(rawText, literalline);\n                }\n                return rawText;\n            }\n        case 'Element':\n        case 'InlineComponent':\n        case 'Slot':\n        case 'SlotTemplate':\n        case 'Window':\n        case 'Head':\n        case 'Title': {\n            const isSupportedLanguage = !(\n                node.name === 'template' && !isNodeSupportedLanguage(node)\n            );\n            const isEmpty = node.children.every((child) => isEmptyTextNode(child));\n            const isDoctypeTag = node.name.toUpperCase() === '!DOCTYPE';\n            const didSelfClose = options.originalText[node.end - 2] === '/';\n\n            const isSelfClosingTag =\n                isEmpty &&\n                ((((node.type === 'Element' && !options.svelteStrictMode) ||\n                    node.type === 'Head' ||\n                    node.type === 'InlineComponent' ||\n                    node.type === 'SlotTemplate' ||\n                    node.type === 'Title') &&\n                    didSelfClose) ||\n                    node.type === 'Slot' ||\n                    node.type === 'Window' ||\n                    selfClosingTags.indexOf(node.name) !== -1 ||\n                    isDoctypeTag);\n\n            // Order important: print attributes first\n            const attributes = path.map(\n                printWithPrependedAttributeLine(node, options, print),\n                'attributes',\n            );\n            const attributeLine = getAttributeLine(node, options);\n            const possibleThisBinding =\n                node.type === 'InlineComponent' && node.expression\n                    ? [attributeLine, 'this=', ...printJsExpression()]\n                    : node.type === 'Element' && node.tag\n                    ? [\n                          attributeLine,\n                          'this=',\n                          ...(typeof node.tag === 'string'\n                              ? [`\"${node.tag}\"`]\n                              : [open, printJS(path, print, 'tag'), close]),\n                      ]\n                    : '';\n\n            if (isSelfClosingTag) {\n                return group([\n                    '<',\n                    node.name,\n\n                    indent(\n                        group([\n                            possibleThisBinding,\n                            ...attributes,\n                            bracketSameLine || isDoctypeTag ? '' : dedent(line),\n                        ]),\n                    ),\n\n                    ...[bracketSameLine && !isDoctypeTag ? ' ' : '', `${isDoctypeTag ? '' : '/'}>`],\n                ]);\n            }\n\n            const children = node.children;\n            const firstChild = children[0];\n            const lastChild = children[children.length - 1];\n\n            // Is a function which is invoked later because printChildren will manipulate child nodes\n            // which would wrongfully change the other checks about hugging etc done beforehand\n            let body: () => Doc;\n\n            const hugStart = shouldHugStart(node, isSupportedLanguage, options);\n            const hugEnd = shouldHugEnd(node, isSupportedLanguage, options);\n\n            if (isEmpty) {\n                body =\n                    isInlineElement(path, options, node) &&\n                    node.children.length &&\n                    isTextNodeStartingWithWhitespace(node.children[0]) &&\n                    !isPreTagContent(path)\n                        ? () => line\n                        : () => (bracketSameLine ? softline : '');\n            } else if (isPreTagContent(path)) {\n                body = () => printPre(node, options.originalText, path, print);\n            } else if (!isSupportedLanguage) {\n                body = () => printRaw(node, options.originalText, true);\n            } else if (isInlineElement(path, options, node) && !isPreTagContent(path)) {\n                body = () => printChildren(path, print, options);\n            } else {\n                body = () => printChildren(path, print, options);\n            }\n\n            const openingTag = [\n                '<',\n                node.name,\n\n                indent(\n                    group([\n                        possibleThisBinding,\n                        ...attributes,\n                        hugStart && !isEmpty\n                            ? ''\n                            : !bracketSameLine && !isPreTagContent(path)\n                            ? dedent(softline)\n                            : '',\n                    ]),\n                ),\n            ];\n\n            if (!isSupportedLanguage && !isEmpty) {\n                // Format template tags so that there's a hardline but no indention.\n                // That way the `lang=\"X\"` and the closing `>` of the start tag stay in one line\n                // which is the 99% use case.\n                return group([\n                    ...openingTag,\n                    '>',\n                    group([hardline, body(), hardline]),\n                    `</${node.name}>`,\n                ]);\n            }\n\n            if (hugStart && hugEnd) {\n                const huggedContent = [softline, group(['>', body(), `</${node.name}`])];\n                const omitSoftlineBeforeClosingTag =\n                    (isEmpty && !bracketSameLine) ||\n                    canOmitSoftlineBeforeClosingTag(node, path, options);\n                return group([\n                    ...openingTag,\n                    isEmpty ? group(huggedContent) : group(indent(huggedContent)),\n                    omitSoftlineBeforeClosingTag ? '' : softline,\n                    '>',\n                ]);\n            }\n\n            // No hugging of content means it's either a block element and/or there's whitespace at the start/end\n            let noHugSeparatorStart: Doc = softline;\n            let noHugSeparatorEnd: Doc = softline;\n            if (isPreTagContent(path)) {\n                noHugSeparatorStart = '';\n                noHugSeparatorEnd = '';\n            } else {\n                let didSetEndSeparator = false;\n\n                if (!hugStart && firstChild && firstChild.type === 'Text') {\n                    if (\n                        isTextNodeStartingWithLinebreak(firstChild) &&\n                        firstChild !== lastChild &&\n                        (!isInlineElement(path, options, node) ||\n                            isTextNodeEndingWithWhitespace(lastChild))\n                    ) {\n                        noHugSeparatorStart = hardline;\n                        noHugSeparatorEnd = hardline;\n                        didSetEndSeparator = true;\n                    } else if (isInlineElement(path, options, node)) {\n                        noHugSeparatorStart = line;\n                    }\n                    trimTextNodeLeft(firstChild);\n                }\n                if (!hugEnd && lastChild && lastChild.type === 'Text') {\n                    if (isInlineElement(path, options, node) && !didSetEndSeparator) {\n                        noHugSeparatorEnd = line;\n                    }\n                    trimTextNodeRight(lastChild);\n                }\n            }\n\n            if (hugStart) {\n                return group([\n                    ...openingTag,\n                    indent([softline, group(['>', body()])]),\n                    noHugSeparatorEnd,\n                    `</${node.name}>`,\n                ]);\n            }\n\n            if (hugEnd) {\n                return group([\n                    ...openingTag,\n                    '>',\n                    indent([noHugSeparatorStart, group([body(), `</${node.name}`])]),\n                    canOmitSoftlineBeforeClosingTag(node, path, options) ? '' : softline,\n                    '>',\n                ]);\n            }\n\n            if (isEmpty) {\n                return group([...openingTag, '>', body(), `</${node.name}>`]);\n            }\n\n            return group([\n                ...openingTag,\n                '>',\n                indent([noHugSeparatorStart, body()]),\n                noHugSeparatorEnd,\n                `</${node.name}>`,\n            ]);\n        }\n        case 'Options':\n            if (options.svelteSortOrder !== 'none') {\n                throw new Error('Options tags should have been handled by prepareChildren');\n            }\n        // else fall through to Body\n        case 'Body':\n        case 'Document':\n            return group([\n                '<',\n                node.name,\n                indent(\n                    group([\n                        ...path.map(\n                            printWithPrependedAttributeLine(node, options, print),\n                            'attributes',\n                        ),\n                        bracketSameLine ? '' : dedent(line),\n                    ]),\n                ),\n                ...[bracketSameLine ? ' ' : '', '/>'],\n            ]);\n        case 'Document':\n            return group([\n                '<',\n                node.name,\n                indent(\n                    group([\n                        ...path.map(\n                            printWithPrependedAttributeLine(node, options, print),\n                            'attributes',\n                        ),\n                        bracketSameLine ? '' : dedent(line),\n                    ]),\n                ),\n                ...[bracketSameLine ? ' ' : '', '/>'],\n            ]);\n        case 'Identifier':\n            return node.name;\n        case 'AttributeShorthand': {\n            return (node.expression as any).name;\n        }\n        case 'Attribute': {\n            if (isOrCanBeConvertedToShorthand(node)) {\n                if (options.svelteAllowShorthand) {\n                    return ['{', node.name, '}'];\n                } else if (options.svelteStrictMode) {\n                    return [node.name, '=\"{', node.name, '}\"'];\n                } else {\n                    return [node.name, '={', node.name, '}'];\n                }\n            } else {\n                if (node.value === true) {\n                    return [node.name];\n                }\n\n                const quotes =\n                    !isLoneMustacheTag(node.value) || (options.svelteStrictMode ?? false);\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n                if (quotes) {\n                    return [node.name, '=', '\"', attrNodeValue, '\"'];\n                } else {\n                    return [node.name, '=', attrNodeValue];\n                }\n            }\n        }\n        case 'MustacheTag':\n            return ['{', printJS(path, print, 'expression'), '}'];\n        case 'IfBlock': {\n            const def: Doc[] = [\n                '{#if ',\n                printJS(path, print, 'expression'),\n                '}',\n                printSvelteBlockChildren(path, print, options),\n            ];\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/if}');\n\n            return group([def, breakParent]);\n        }\n        case 'ElseBlock': {\n            // Else if\n            const parent = path.getParentNode() as Node;\n\n            if (\n                node.children.length === 1 &&\n                node.children[0].type === 'IfBlock' &&\n                parent.type !== 'EachBlock'\n            ) {\n                const ifNode = node.children[0] as IfBlockNode;\n                const def: Doc[] = [\n                    '{:else if ',\n                    path.map((ifPath) => printJS(ifPath, print, 'expression'), 'children')[0],\n                    '}',\n                    path.map(\n                        (ifPath) => printSvelteBlockChildren(ifPath, print, options),\n                        'children',\n                    )[0],\n                ];\n\n                if (ifNode.else) {\n                    def.push(\n                        path.map(\n                            (ifPath: FastPath<any>) => ifPath.call(print, 'else'),\n                            'children',\n                        )[0],\n                    );\n                }\n                return def;\n            }\n\n            return ['{:else}', printSvelteBlockChildren(path, print, options)];\n        }\n        case 'EachBlock': {\n            const def: Doc[] = [\n                '{#each ',\n                printJS(path, print, 'expression'),\n                ' as',\n                expandNode(node.context, options.originalText),\n            ];\n\n            if (node.index) {\n                def.push(', ', node.index);\n            }\n\n            if (node.key) {\n                def.push(' (', printJS(path, print, 'key'), ')');\n            }\n\n            def.push('}', printSvelteBlockChildren(path, print, options));\n\n            if (node.else) {\n                def.push(path.call(print, 'else'));\n            }\n\n            def.push('{/each}');\n\n            return group([def, breakParent]);\n        }\n        case 'AwaitBlock': {\n            const hasPendingBlock = node.pending.children.some((n) => !isEmptyTextNode(n));\n            const hasThenBlock = node.then.children.some((n) => !isEmptyTextNode(n));\n            const hasCatchBlock = node.catch.children.some((n) => !isEmptyTextNode(n));\n\n            let block = [];\n\n            if (!hasPendingBlock && hasThenBlock) {\n                block.push(\n                    group([\n                        '{#await ',\n                        printJS(path, print, 'expression'),\n                        ' then',\n                        expandNode(node.value, options.originalText),\n                        '}',\n                    ]),\n                    path.call(print, 'then'),\n                );\n            } else if (!hasPendingBlock && hasCatchBlock) {\n                block.push(\n                    group([\n                        '{#await ',\n                        printJS(path, print, 'expression'),\n                        ' catch',\n                        expandNode(node.error, options.originalText),\n                        '}',\n                    ]),\n                    path.call(print, 'catch'),\n                );\n            } else {\n                block.push(group(['{#await ', printJS(path, print, 'expression'), '}']));\n\n                if (hasPendingBlock) {\n                    block.push(path.call(print, 'pending'));\n                }\n\n                if (hasThenBlock) {\n                    block.push(\n                        group(['{:then', expandNode(node.value, options.originalText), '}']),\n                        path.call(print, 'then'),\n                    );\n                }\n            }\n\n            if ((hasPendingBlock || hasThenBlock) && hasCatchBlock) {\n                block.push(\n                    group(['{:catch', expandNode(node.error, options.originalText), '}']),\n                    path.call(print, 'catch'),\n                );\n            }\n\n            block.push('{/await}');\n\n            return group(block);\n        }\n        case 'KeyBlock': {\n            const def: Doc[] = [\n                '{#key ',\n                printJS(path, print, 'expression'),\n                '}',\n                printSvelteBlockChildren(path, print, options),\n            ];\n\n            def.push('{/key}');\n\n            return group([def, breakParent]);\n        }\n        case 'ThenBlock':\n        case 'PendingBlock':\n        case 'CatchBlock':\n            return printSvelteBlockChildren(path, print, options);\n        // Svelte 5 only\n        case 'SnippetBlock': {\n            const snippet = ['{#snippet ', printJS(path, print, 'expression')];\n            snippet.push('}', printSvelteBlockChildren(path, print, options), '{/snippet}');\n            return snippet;\n        }\n        case 'EventHandler':\n            return [\n                'on:',\n                node.name,\n                node.modifiers && node.modifiers.length ? ['|', join('|', node.modifiers)] : '',\n                node.expression ? ['=', ...printJsExpression()] : '',\n            ];\n        case 'Binding':\n            return [\n                'bind:',\n                node.name,\n                node.expression.type === 'Identifier' &&\n                node.expression.name === node.name &&\n                options.svelteAllowShorthand\n                    ? ''\n                    : ['=', ...printJsExpression()],\n            ];\n        case 'Class':\n            return [\n                'class:',\n                node.name,\n                node.expression.type === 'Identifier' &&\n                node.expression.name === node.name &&\n                options.svelteAllowShorthand\n                    ? ''\n                    : ['=', ...printJsExpression()],\n            ];\n        case 'StyleDirective':\n            const prefix = [\n                'style:',\n                node.name,\n                node.modifiers && node.modifiers.length ? ['|', join('|', node.modifiers)] : '',\n            ];\n\n            if (isOrCanBeConvertedToShorthand(node) || node.value === true) {\n                if (options.svelteAllowShorthand) {\n                    return [...prefix];\n                } else if (options.svelteStrictMode) {\n                    return [...prefix, '=\"{', node.name, '}\"'];\n                } else {\n                    return [...prefix, '={', node.name, '}'];\n                }\n            } else {\n                const quotes =\n                    !isLoneMustacheTag(node.value) || (options.svelteStrictMode ?? false);\n                const attrNodeValue = printAttributeNodeValue(path, print, quotes, node);\n                if (quotes) {\n                    return [...prefix, '=', '\"', attrNodeValue, '\"'];\n                } else {\n                    return [...prefix, '=', attrNodeValue];\n                }\n            }\n        case 'Let':\n            return [\n                'let:',\n                node.name,\n                // shorthand let directives have `null` expressions\n                !node.expression ||\n                (node.expression.type === 'Identifier' && node.expression.name === node.name)\n                    ? ''\n                    : ['=', ...printJsExpression()],\n            ];\n        case 'DebugTag':\n            return [\n                '{@debug',\n                node.identifiers.length > 0\n                    ? [' ', join(', ', path.map(print, 'identifiers'))]\n                    : '',\n                '}',\n            ];\n        case 'Ref':\n            return ['ref:', node.name];\n        case 'Comment': {\n            const nodeAfterComment = getNextNode(path);\n\n            if (isIgnoreStartDirective(node) && isNodeTopLevelHTML(node, path)) {\n                ignoreRange = true;\n            } else if (isIgnoreEndDirective(node) && isNodeTopLevelHTML(node, path)) {\n                ignoreRange = false;\n            } else if (\n                // If there is no sibling node that starts right after us but the parent indicates\n                // that there used to be, that means that node was actually an embedded `<style>`\n                // or `<script>` node that was cut out.\n                // If so, the comment does not refer to the next line we will see.\n                // The `embed` function handles printing the comment in the right place.\n                doesEmbedStartAfterNode(node, path) ||\n                (isEmptyTextNode(nodeAfterComment) &&\n                    doesEmbedStartAfterNode(nodeAfterComment, path))\n            ) {\n                return '';\n            } else if (isIgnoreDirective(node)) {\n                ignoreNext = true;\n            }\n\n            return printComment(node);\n        }\n        case 'Transition':\n            const kind = node.intro && node.outro ? 'transition' : node.intro ? 'in' : 'out';\n            return [\n                kind,\n                ':',\n                node.name,\n                node.modifiers && node.modifiers.length ? ['|', join('|', node.modifiers)] : '',\n                node.expression ? ['=', ...printJsExpression()] : '',\n            ];\n        case 'Action':\n            return ['use:', node.name, node.expression ? ['=', ...printJsExpression()] : ''];\n        case 'Animation':\n            return ['animate:', node.name, node.expression ? ['=', ...printJsExpression()] : ''];\n        case 'RawMustacheTag':\n            return ['{@html ', printJS(path, print, 'expression'), '}'];\n        // Svelte 5 only\n        case 'RenderTag': {\n            const render = ['{@render ', printJS(path, print, 'expression'), '}'];\n            return render;\n        }\n        case 'Spread':\n            return ['{...', printJS(path, print, 'expression'), '}'];\n        case 'ConstTag':\n            return ['{@const ', printJS(path, print, 'expression'), '}'];\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction printTopLevelParts(\n    n: ASTNode,\n    options: ParserOptions,\n    path: FastPath<any>,\n    print: PrintFn,\n): Doc {\n    if (options.svelteSortOrder === 'none') {\n        const topLevelPartsByEnd: Record<number, any> = {};\n\n        if (n.module) {\n            topLevelPartsByEnd[n.module.end] = n.module;\n        }\n        if (n.instance) {\n            topLevelPartsByEnd[n.instance.end] = n.instance;\n        }\n        if (n.css) {\n            topLevelPartsByEnd[n.css.end] = n.css;\n        }\n\n        const children = getChildren(n.html);\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (topLevelPartsByEnd[node.start]) {\n                children.splice(i, 0, topLevelPartsByEnd[node.start]);\n                delete topLevelPartsByEnd[node.start];\n            }\n        }\n\n        const result = path.call(print, 'html');\n        if (options.insertPragma && !hasPragma(options.originalText)) {\n            return [`<!-- @format -->`, hardline, result];\n        } else {\n            return result;\n        }\n    }\n\n    const parts: Record<SortOrderPart, Doc[]> = {\n        options: [],\n        scripts: [],\n        markup: [],\n        styles: [],\n    };\n\n    // scripts\n    if (n.module) {\n        parts.scripts.push(path.call(print, 'module'));\n    }\n    if (n.instance) {\n        parts.scripts.push(path.call(print, 'instance'));\n    }\n\n    // styles\n    if (n.css) {\n        parts.styles.push(path.call(print, 'css'));\n    }\n\n    // markup\n    const htmlDoc = path.call(print, 'html');\n    if (htmlDoc) {\n        parts.markup.push(htmlDoc);\n    }\n    if (svelteOptionsDoc) {\n        parts.options.push(svelteOptionsDoc);\n    }\n\n    const docs = flatten(parseSortOrder(options.svelteSortOrder).map((p) => parts[p]));\n\n    // Need to reset these because they are global and could affect the next formatting run\n    ignoreNext = false;\n    ignoreRange = false;\n    svelteOptionsDoc = undefined;\n\n    // If this is invoked as an embed of markdown, remove the last hardline.\n    // The markdown parser tries this, too, but fails because it does not\n    // recurse into concats. Doing this will prevent an empty line\n    // at the end of the embedded code block.\n    if (options.parentParser === 'markdown') {\n        const lastDoc = docs[docs.length - 1];\n        trimRight([lastDoc], isLine);\n    }\n\n    if (options.insertPragma && !hasPragma(options.originalText)) {\n        return [`<!-- @format -->`, hardline, group(docs)];\n    } else {\n        return group([join(hardline, docs)]);\n    }\n}\n\nfunction printAttributeNodeValue(\n    path: FastPath<any>,\n    print: PrintFn,\n    quotes: boolean,\n    node: AttributeNode | StyleDirectiveNode,\n) {\n    const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n    if (!quotes || !formattableAttributes.includes(node.name)) {\n        return valueDocs;\n    } else {\n        return indent(group(trim(valueDocs, isLine)));\n    }\n}\n\nfunction printSvelteBlockChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\n    const node = path.getValue();\n    const children = node.children;\n    if (!children || children.length === 0) {\n        return '';\n    }\n\n    const whitespaceAtStartOfBlock = checkWhitespaceAtStartOfSvelteBlock(node, options);\n    const whitespaceAtEndOfBlock = checkWhitespaceAtEndOfSvelteBlock(node, options);\n    const startline =\n        whitespaceAtStartOfBlock === 'none'\n            ? ''\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\n            ? hardline\n            : line;\n    const endline =\n        whitespaceAtEndOfBlock === 'none'\n            ? ''\n            : whitespaceAtEndOfBlock === 'line' || whitespaceAtStartOfBlock === 'line'\n            ? hardline\n            : line;\n\n    const firstChild = children[0];\n    const lastChild = children[children.length - 1];\n    if (isTextNodeStartingWithWhitespace(firstChild)) {\n        trimTextNodeLeft(firstChild);\n    }\n    if (isTextNodeEndingWithWhitespace(lastChild)) {\n        trimTextNodeRight(lastChild);\n    }\n\n    return [indent([startline, group(printChildren(path, print, options))]), endline];\n}\n\nfunction printPre(\n    node: Parameters<typeof printRaw>[0],\n    originalText: string,\n    path: FastPath,\n    print: PrintFn,\n): Doc {\n    const result: Doc = [];\n    const length = node.children.length;\n    for (let i = 0; i < length; i++) {\n        const child = node.children[i];\n        if (child.type === 'Text') {\n            const lines = originalText.substring(child.start, child.end).split(/\\r?\\n/);\n            lines.forEach((line, j) => {\n                if (j > 0) result.push(literalline);\n                result.push(line);\n            });\n        } else {\n            result.push(path.call(print, 'children', i));\n        }\n    }\n    return result;\n}\n\nfunction printChildren(path: FastPath, print: PrintFn, options: ParserOptions): Doc {\n    if (isPreTagContent(path)) {\n        return path.map(print, 'children');\n    }\n\n    const childNodes: Node[] = prepareChildren(path.getValue().children, path, print, options);\n    // modify original array because it's accessed later through map(print, 'children', idx)\n    path.getValue().children = childNodes;\n    if (childNodes.length === 0) {\n        return '';\n    }\n\n    const childDocs: Doc[] = [];\n    let handleWhitespaceOfPrevTextNode = false;\n\n    for (let i = 0; i < childNodes.length; i++) {\n        const childNode = childNodes[i];\n        if (childNode.type === 'Text') {\n            handleTextChild(i, childNode);\n        } else if (isBlockElement(childNode, options)) {\n            handleBlockChild(i);\n        } else if (isInlineElement(path, options, childNode)) {\n            handleInlineChild(i);\n        } else {\n            childDocs.push(printChild(i));\n            handleWhitespaceOfPrevTextNode = false;\n        }\n    }\n\n    // If there's at least one block element and more than one node, break content\n    const forceBreakContent =\n        childNodes.length > 1 && childNodes.some((child) => isBlockElement(child, options));\n    if (forceBreakContent) {\n        childDocs.push(breakParent);\n    }\n\n    return childDocs;\n\n    function printChild(idx: number): Doc {\n        return path.call(print, 'children', idx);\n    }\n\n    /**\n     * Print inline child. Hug whitespace of previous text child if there was one.\n     */\n    function handleInlineChild(idx: number) {\n        if (handleWhitespaceOfPrevTextNode) {\n            childDocs.push(group([line, printChild(idx)]));\n        } else {\n            childDocs.push(printChild(idx));\n        }\n        handleWhitespaceOfPrevTextNode = false;\n    }\n\n    /**\n     * Print block element. Add softlines around it if needed\n     * so it breaks into a separate line if children are broken up.\n     * Don't add lines at the start/end if it's the first/last child because this\n     * kind of whitespace handling is done in the parent already.\n     */\n    function handleBlockChild(idx: number) {\n        const prevChild = childNodes[idx - 1];\n        if (\n            prevChild &&\n            !isBlockElement(prevChild, options) &&\n            (prevChild.type !== 'Text' ||\n                handleWhitespaceOfPrevTextNode ||\n                !isTextNodeEndingWithWhitespace(prevChild))\n        ) {\n            childDocs.push(softline);\n        }\n\n        childDocs.push(printChild(idx));\n\n        const nextChild = childNodes[idx + 1];\n        if (\n            nextChild &&\n            (nextChild.type !== 'Text' ||\n                // Only handle text which starts with a whitespace and has text afterwards,\n                // or is empty but followed by an inline element. The latter is done\n                // so that if the children break, the inline element afterwards is in a separate line.\n                ((!isEmptyTextNode(nextChild) ||\n                    (childNodes[idx + 2] && isInlineElement(path, options, childNodes[idx + 2]))) &&\n                    !isTextNodeStartingWithLinebreak(nextChild)))\n        ) {\n            childDocs.push(softline);\n        }\n        handleWhitespaceOfPrevTextNode = false;\n    }\n\n    /**\n     * Print text child. First/last child white space handling\n     * is done in parent already. By definition of the Svelte AST,\n     * a text node always is inbetween other tags. Add hardlines\n     * if the users wants to have them inbetween.\n     * If the text is trimmed right, toggle flag telling\n     * subsequent (inline)block element to alter its printing logic\n     * to check if they need to hug or print lines themselves.\n     */\n    function handleTextChild(idx: number, childNode: TextNode) {\n        handleWhitespaceOfPrevTextNode = false;\n\n        if (idx === 0 || idx === childNodes.length - 1) {\n            childDocs.push(printChild(idx));\n            return;\n        }\n\n        const prevNode = childNodes[idx - 1];\n        const nextNode = childNodes[idx + 1];\n\n        if (\n            isTextNodeStartingWithWhitespace(childNode) &&\n            // If node is empty, go straight through to checking the right end\n            !isEmptyTextNode(childNode)\n        ) {\n            if (\n                isInlineElement(path, options, prevNode) &&\n                !isTextNodeStartingWithLinebreak(childNode)\n            ) {\n                trimTextNodeLeft(childNode);\n                const lastChildDoc = childDocs.pop()!;\n                childDocs.push(group([lastChildDoc, line]));\n            }\n\n            if (isBlockElement(prevNode, options) && !isTextNodeStartingWithLinebreak(childNode)) {\n                trimTextNodeLeft(childNode);\n            }\n        }\n\n        if (isTextNodeEndingWithWhitespace(childNode)) {\n            if (\n                isInlineElement(path, options, nextNode) &&\n                !isTextNodeEndingWithLinebreak(childNode)\n            ) {\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\n                trimTextNodeRight(childNode);\n            }\n            if (isBlockElement(nextNode, options) && !isTextNodeEndingWithLinebreak(childNode, 2)) {\n                handleWhitespaceOfPrevTextNode = !prevNode || !isBlockElement(prevNode, options);\n                trimTextNodeRight(childNode);\n            }\n        }\n\n        childDocs.push(printChild(idx));\n    }\n}\n\n/**\n * `svelte:options` is part of the html part but needs to be snipped out and handled\n * separately to reorder it as configured. The comment above it should be moved with it.\n * Do that here.\n */\nfunction prepareChildren(\n    children: Node[],\n    path: FastPath,\n    print: PrintFn,\n    options: ParserOptions,\n): Node[] {\n    let svelteOptionsComment: Doc | undefined;\n    const childrenWithoutOptions = [];\n    const bracketSameLine = isBracketSameLine(options);\n\n    for (let idx = 0; idx < children.length; idx++) {\n        const currentChild = children[idx];\n\n        if (currentChild.type === 'Text' && getUnencodedText(currentChild) === '') {\n            continue;\n        }\n\n        if (isEmptyTextNode(currentChild) && doesEmbedStartAfterNode(currentChild, path)) {\n            continue;\n        }\n\n        if (options.svelteSortOrder !== 'none') {\n            if (isCommentFollowedByOptions(currentChild, idx)) {\n                svelteOptionsComment = printComment(currentChild);\n                const nextChild = children[idx + 1];\n                idx += nextChild && isEmptyTextNode(nextChild) ? 1 : 0;\n                continue;\n            }\n\n            if (currentChild.type === 'Options') {\n                printSvelteOptions(currentChild, idx, path, print);\n                continue;\n            }\n        }\n\n        childrenWithoutOptions.push(currentChild);\n    }\n\n    const mergedChildrenWithoutOptions = [];\n\n    for (let idx = 0; idx < childrenWithoutOptions.length; idx++) {\n        const currentChild = childrenWithoutOptions[idx];\n        const nextChild = childrenWithoutOptions[idx + 1];\n\n        if (currentChild.type === 'Text' && nextChild && nextChild.type === 'Text') {\n            // A tag was snipped out (f.e. svelte:options). Join text\n            currentChild.raw += nextChild.raw;\n            currentChild.data += nextChild.data;\n            idx++;\n        }\n\n        mergedChildrenWithoutOptions.push(currentChild);\n    }\n\n    return mergedChildrenWithoutOptions;\n\n    function printSvelteOptions(\n        node: OptionsNode,\n        idx: number,\n        path: FastPath,\n        print: PrintFn,\n    ): void {\n        svelteOptionsDoc = group([\n            [\n                '<',\n                node.name,\n                indent(\n                    group([\n                        ...path.map(\n                            printWithPrependedAttributeLine(node, options, print),\n                            'children',\n                            idx,\n                            'attributes',\n                        ),\n                        bracketSameLine ? '' : dedent(line),\n                    ]),\n                ),\n                ...[bracketSameLine ? ' ' : '', '/>'],\n            ],\n            hardline,\n        ]);\n        if (svelteOptionsComment) {\n            svelteOptionsDoc = group([svelteOptionsComment, hardline, svelteOptionsDoc]);\n        }\n    }\n\n    function isCommentFollowedByOptions(node: Node, idx: number): node is CommentNode {\n        if (node.type !== 'Comment' || isIgnoreEndDirective(node) || isIgnoreStartDirective(node)) {\n            return false;\n        }\n\n        const nextChild = children[idx + 1];\n        if (nextChild) {\n            if (isEmptyTextNode(nextChild)) {\n                const afterNext = children[idx + 2];\n                return afterNext && afterNext.type === 'Options';\n            }\n            return nextChild.type === 'Options';\n        }\n\n        return false;\n    }\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: TextNode): Doc[] {\n    const text = getUnencodedText(node);\n    const lines = text.split(/[\\t\\n\\f\\r ]+/);\n\n    let docs = join(line, lines).filter((doc) => doc !== '');\n\n    if (startsWithLinebreak(text)) {\n        docs[0] = hardline;\n    }\n    if (startsWithLinebreak(text, 2)) {\n        docs = [hardline, ...docs];\n    }\n\n    if (endsWithLinebreak(text)) {\n        docs[docs.length - 1] = hardline;\n    }\n    if (endsWithLinebreak(text, 2)) {\n        docs = [...docs, hardline];\n    }\n\n    return docs;\n}\n\nfunction printJS(path: FastPath, print: PrintFn, name: string) {\n    return path.call(print, name);\n}\n\nfunction expandNode(node: any, original: string): string {\n    let str = _expandNode(node);\n    if (node?.typeAnnotation) {\n        str += ': ' + original.slice(node.typeAnnotation.start, node.typeAnnotation.end);\n    }\n    return str;\n}\n\nfunction _expandNode(node: any, parent?: any): string {\n    if (node === null) {\n        return '';\n    }\n\n    if (typeof node === 'string') {\n        // pre-v3.20 AST\n        return ' ' + node;\n    }\n\n    switch (node.type) {\n        case 'ArrayExpression':\n        case 'ArrayPattern':\n            return ' [' + node.elements.map(_expandNode).join(',').slice(1) + ']';\n        case 'AssignmentPattern':\n            return _expandNode(node.left) + ' =' + _expandNode(node.right);\n        case 'Identifier':\n            return ' ' + node.name;\n        case 'Literal':\n            return ' ' + node.raw;\n        case 'ObjectExpression':\n            return ' {' + node.properties.map((p: any) => _expandNode(p, node)).join(',') + ' }';\n        case 'ObjectPattern':\n            return ' {' + node.properties.map(_expandNode).join(',') + ' }';\n        case 'Property':\n            if (node.value.type === 'ObjectPattern' || node.value.type === 'ArrayPattern') {\n                return ' ' + node.key.name + ':' + _expandNode(node.value);\n            } else if (\n                (node.value.type === 'Identifier' && node.key.name !== node.value.name) ||\n                (parent && parent.type === 'ObjectExpression')\n            ) {\n                return _expandNode(node.key) + ':' + _expandNode(node.value);\n            } else {\n                return _expandNode(node.value);\n            }\n        case 'RestElement':\n            return ' ...' + node.argument.name;\n    }\n\n    console.error(JSON.stringify(node, null, 4));\n    throw new Error('unknown node type: ' + node.type);\n}\n\nfunction printComment(node: CommentNode) {\n    let text = node.data;\n\n    if (hasSnippedContent(text)) {\n        text = unsnipContent(text);\n    }\n\n    return group(['<!--', text, '-->']);\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n};\n","import { ParserOptions } from '../options';\nimport { Node } from '../print/nodes';\nimport { hasSnippedContent, unsnipContent } from './snipTagContent';\n\nexport function getText(node: Node, options: ParserOptions, unsnip = false) {\n    const leadingComments: Node[] = (node as any).leadingComments;\n    const text = options.originalText.slice(\n        options.locStart(\n            // if there are comments before the node they are not included\n            // in the `start` of the node itself\n            (leadingComments && leadingComments[0]) || node,\n        ),\n        options.locEnd(node),\n    );\n\n    if (!unsnip || !hasSnippedContent(text)) {\n        return text;\n    }\n\n    return unsnipContent(text);\n}\n","import { AttributeNode, TextNode } from '../print/nodes';\n\nconst extractAttributesRegex =\n    /<[a-z]+((?:\\s+[^=>'\"\\/]+=(?:\"[^\"]*\"|'[^']*'|[^>\\s]+)|\\s+[^=>'\"\\/]+)*\\s*)>/im;\nconst attributeRegex = /([^\\s=]+)(?:=(?:(?:(\"|')([\\s\\S]*?)\\2)|(?:([^>\\s]+?)(?:\\s|>|$))))?/gim;\n\nexport function extractAttributes(html: string): AttributeNode[] {\n    const [, attributesString] = html.match(extractAttributesRegex)!;\n\n    const attrs: AttributeNode[] = [];\n\n    let match: RegExpMatchArray | null;\n    while ((match = attributeRegex.exec(attributesString))) {\n        const [all, name, quotes, valueQuoted, valueUnquoted] = match;\n        const value = valueQuoted || valueUnquoted;\n        const attrStart = match.index!;\n\n        let valueNode: AttributeNode['value'];\n        if (!value) {\n            valueNode = true;\n        } else {\n            let valueStart = attrStart + name.length;\n            if (quotes) {\n                valueStart += 2;\n            }\n\n            valueNode = [\n                {\n                    type: 'Text',\n                    data: value,\n                    start: valueStart,\n                    end: valueStart + value.length,\n                } as TextNode,\n            ];\n        }\n\n        attrs.push({\n            type: 'Attribute',\n            name,\n            value: valueNode,\n            start: attrStart,\n            end: attrStart + all.length,\n        });\n    }\n\n    return attrs;\n}\n","import { Doc, doc, FastPath, Options } from 'prettier';\nimport { getText } from './lib/getText';\nimport { snippedTagContentAttribute } from './lib/snipTagContent';\nimport { isBracketSameLine, ParserOptions } from './options';\nimport { PrintFn } from './print';\nimport { isLine, removeParentheses, trimRight } from './print/doc-helpers';\nimport { isASTNode, printWithPrependedAttributeLine } from './print/helpers';\nimport {\n    assignCommentsToNodes,\n    getAttributeTextValue,\n    getLeadingComment,\n    isIgnoreDirective,\n    isInsideQuotedAttribute,\n    isLess,\n    isNodeSupportedLanguage,\n    isPugTemplate,\n    isScss,\n    isTypeScript,\n    printRaw,\n} from './print/node-helpers';\nimport { CommentNode, ElementNode, Node, ScriptNode, StyleNode } from './print/nodes';\nimport { extractAttributes } from './lib/extractAttributes';\n\nconst {\n    builders: { group, hardline, softline, indent, dedent, literalline },\n    utils: { removeLines },\n} = doc;\n\nconst leaveAlone = new Set([\n    'Script',\n    'Style',\n    'Identifier',\n    'MemberExpression',\n    'CallExpression',\n    'ArrowFunctionExpression',\n]);\nconst dontTraverse = new Set(['start', 'end', 'type']);\n\nexport function getVisitorKeys(node: any, nonTraversableKeys: Set<string>): string[] {\n    return Object.keys(node).filter((key) => {\n        return !nonTraversableKeys.has(key) && !leaveAlone.has(node.type) && !dontTraverse.has(key);\n    });\n}\n\n// Embed works like this in Prettier v3:\n// - do depth first traversal of all node properties\n// - deepest property is calling embed first\n// - if embed returns a function, it will be called after the traversal in a second pass, in the same order (deepest first)\n// For performance reasons we try to only return functions when we're sure we need to transform something.\nexport function embed(path: FastPath, _options: Options) {\n    const node: Node = path.getNode();\n    const options = _options as ParserOptions;\n    if (!options.locStart || !options.locEnd || !options.originalText) {\n        throw new Error('Missing required options');\n    }\n\n    if (isASTNode(node)) {\n        assignCommentsToNodes(node);\n        if (node.module) {\n            node.module.type = 'Script';\n            node.module.attributes = extractAttributes(getText(node.module, options));\n        }\n        if (node.instance) {\n            node.instance.type = 'Script';\n            node.instance.attributes = extractAttributes(getText(node.instance, options));\n        }\n        if (node.css) {\n            node.css.type = 'Style';\n            node.css.content.type = 'StyleProgram';\n        }\n        return null;\n    }\n\n    // embed does depth first traversal with deepest node called first, therefore we need to\n    // check the parent to see if we are inside an expression that should be embedded.\n    const parent = path.getParentNode();\n    const printJsExpression = () =>\n        (parent as any).expression\n            ? printJS(parent, options.svelteStrictMode ?? false, false, false, 'expression')\n            : undefined;\n    const printSvelteBlockJS = (name: string) => printJS(parent, false, true, false, name);\n\n    switch (parent.type) {\n        case 'IfBlock':\n        case 'ElseBlock':\n        case 'AwaitBlock':\n        case 'KeyBlock':\n            printSvelteBlockJS('expression');\n            break;\n        case 'EachBlock':\n            printSvelteBlockJS('expression');\n            printSvelteBlockJS('key');\n            break;\n        case 'SnippetBlock':\n            // We merge the two parts into one expression, which future-proofs this for template TS support\n            if (node === parent.expression) {\n                parent.expression.end =\n                    options.originalText.indexOf(\n                        ')',\n                        parent.context?.end ?? parent.expression.end,\n                    ) + 1;\n                parent.context = null;\n                printSvelteBlockJS('expression');\n            }\n            break;\n        case 'Element':\n            printJS(parent, options.svelteStrictMode ?? false, false, false, 'tag');\n            break;\n        case 'MustacheTag':\n            printJS(parent, isInsideQuotedAttribute(path, options), false, false, 'expression');\n            break;\n        case 'RawMustacheTag':\n            printJS(parent, false, false, false, 'expression');\n            break;\n        case 'Spread':\n            printJS(parent, false, false, false, 'expression');\n            break;\n        case 'ConstTag':\n            printJS(parent, false, false, true, 'expression');\n            break;\n        case 'RenderTag':\n            // We merge the two parts into one expression, which future-proofs this for template TS support\n            if (node === parent.expression) {\n                parent.expression.end =\n                    options.originalText.indexOf(\n                        ')',\n                        parent.argument?.end ?? parent.expression.end,\n                    ) + 1;\n                parent.argument = null;\n                printJS(parent, false, false, false, 'expression');\n            }\n            break;\n        case 'EventHandler':\n        case 'Binding':\n        case 'Class':\n        case 'Let':\n        case 'Transition':\n        case 'Action':\n        case 'Animation':\n        case 'InlineComponent':\n            printJsExpression();\n            break;\n    }\n\n    if (node.isJS) {\n        return async (\n            textToDoc: (text: string, options: Options) => Promise<Doc>,\n        ): Promise<Doc> => {\n            try {\n                const embeddedOptions = {\n                    // Prettier only allows string references as parsers from v3 onwards,\n                    // so we need to have another public parser and defer to that\n                    parser: 'svelteExpressionParser',\n                    singleQuote: node.forceSingleQuote ? true : options.singleQuote,\n                };\n\n                let docs = await textToDoc(\n                    forceIntoExpression(\n                        // If we have snipped content, it was done wrongly and we need to unsnip it.\n                        // This happens for example for {@html `<script>{foo}</script>`}\n                        getText(node, options, true),\n                    ),\n                    embeddedOptions,\n                );\n                if (node.forceSingleLine) {\n                    docs = removeLines(docs);\n                }\n                if (node.removeParentheses) {\n                    docs = removeParentheses(docs);\n                }\n                return docs;\n            } catch (e) {\n                return getText(node, options, true);\n            }\n        };\n    }\n\n    const embedType = (\n        tag: 'script' | 'style' | 'template',\n        parser: 'typescript' | 'babel-ts' | 'css' | 'scss' | 'less' | 'pug',\n        isTopLevel: boolean,\n    ) => {\n        return async (\n            textToDoc: (text: string, options: Options) => Promise<Doc>,\n            print: PrintFn,\n        ): Promise<Doc> => {\n            return embedTag(\n                tag,\n                options.originalText,\n                path,\n                (content) => formatBodyContent(content, parser, textToDoc, options),\n                print,\n                isTopLevel,\n                options,\n            );\n        };\n    };\n\n    const embedScript = (isTopLevel: boolean) =>\n        embedType(\n            'script',\n            // Use babel-ts as fallback because the absence does not mean the content is not TS,\n            // the user could have set the default language. babel-ts will format things a little\n            // bit different though, especially preserving parentheses around dot notation which\n            // fixes https://github.com/sveltejs/prettier-plugin-svelte/issues/218\n            isTypeScript(node) ? 'typescript' : 'babel-ts',\n            isTopLevel,\n        );\n    const embedStyle = (isTopLevel: boolean) =>\n        embedType('style', isLess(node) ? 'less' : isScss(node) ? 'scss' : 'css', isTopLevel);\n    const embedPug = () => embedType('template', 'pug', false);\n\n    switch (node.type) {\n        case 'Script':\n            return embedScript(true);\n        case 'Style':\n            return embedStyle(true);\n        case 'Element': {\n            if (node.name === 'script') {\n                return embedScript(false);\n            } else if (node.name === 'style') {\n                return embedStyle(false);\n            } else if (isPugTemplate(node)) {\n                return embedPug();\n            }\n        }\n    }\n\n    return null;\n}\n\nfunction forceIntoExpression(statement: string) {\n    // note the trailing newline: if the statement ends in a // comment,\n    // we can't add the closing bracket right afterwards\n    return `(${statement}\\n)`;\n}\n\nfunction preformattedBody(str: string): Doc {\n    if (!str) {\n        return '';\n    }\n\n    const firstNewline = /^[\\t\\f\\r ]*\\n/;\n    const lastNewline = /\\n[\\t\\f\\r ]*$/;\n\n    // If we do not start with a new line prettier might try to break the opening tag\n    // to keep it together with the string. Use a literal line to skip indentation.\n    return [literalline, str.replace(firstNewline, '').replace(lastNewline, ''), hardline];\n}\n\nfunction getSnippedContent(node: Node) {\n    const encodedContent = getAttributeTextValue(snippedTagContentAttribute, node);\n\n    if (encodedContent) {\n        return Buffer.from(encodedContent, 'base64').toString('utf-8');\n    } else {\n        return '';\n    }\n}\n\nasync function formatBodyContent(\n    content: string,\n    parser: 'typescript' | 'babel-ts' | 'css' | 'scss' | 'less' | 'pug',\n    textToDoc: (text: string, options: object) => Promise<Doc>,\n    options: ParserOptions & { pugTabWidth?: number },\n) {\n    try {\n        const body = await textToDoc(content, { parser });\n\n        if (parser === 'pug' && typeof body === 'string') {\n            // Pug returns no docs but a final string.\n            // Therefore prepend the line offsets\n            const whitespace = options.useTabs\n                ? '\\t'\n                : ' '.repeat(\n                      options.pugTabWidth && options.pugTabWidth > 0\n                          ? options.pugTabWidth\n                          : options.tabWidth,\n                  );\n            const pugBody = body\n                .split('\\n')\n                .map((line) => (line ? whitespace + line : line))\n                .join('\\n');\n            return [hardline, pugBody];\n        }\n\n        const indentIfDesired = (doc: Doc) =>\n            options.svelteIndentScriptAndStyle ? indent(doc) : doc;\n        trimRight([body], isLine);\n        return [indentIfDesired([hardline, body]), hardline];\n    } catch (error) {\n        if (process.env.PRETTIER_DEBUG) {\n            throw error;\n        }\n\n        // We will wind up here if there is a syntax error in the embedded code. If we throw an error,\n        // prettier will try to print the node with the printer. That will fail with a hard-to-interpret\n        // error message (e.g. \"Unsupported node type\", referring to `<script>`).\n        // Therefore, fall back on just returning the unformatted text.\n        console.error(error);\n\n        return preformattedBody(content);\n    }\n}\n\nasync function embedTag(\n    tag: 'script' | 'style' | 'template',\n    text: string,\n    path: FastPath,\n    formatBodyContent: (content: string) => Promise<Doc>,\n    print: PrintFn,\n    isTopLevel: boolean,\n    options: ParserOptions,\n) {\n    const node: ScriptNode | StyleNode | ElementNode = path.getNode();\n    const content =\n        tag === 'template' ? printRaw(node as ElementNode, text) : getSnippedContent(node);\n    const previousComments =\n        node.type === 'Script' || node.type === 'Style'\n            ? node.comments\n            : [getLeadingComment(path)]\n                  .filter(Boolean)\n                  .map((comment) => ({ comment: comment as CommentNode, emptyLineAfter: false }));\n\n    const canFormat =\n        isNodeSupportedLanguage(node) &&\n        !isIgnoreDirective(previousComments[previousComments.length - 1]?.comment) &&\n        (tag !== 'template' ||\n            options.plugins.some(\n                (plugin) => typeof plugin !== 'string' && plugin.parsers && plugin.parsers.pug,\n            ));\n    const body: Doc = canFormat\n        ? content.trim() !== ''\n            ? await formatBodyContent(content)\n            : content === ''\n            ? ''\n            : hardline\n        : preformattedBody(content);\n\n    const openingTag = group([\n        '<',\n        tag,\n        indent(\n            group([\n                ...path.map(printWithPrependedAttributeLine(node, options, print), 'attributes'),\n                isBracketSameLine(options) ? '' : dedent(softline),\n            ]),\n        ),\n        '>',\n    ]);\n    let result: Doc = group([openingTag, body, '</', tag, '>']);\n\n    const comments = [];\n    for (const comment of previousComments) {\n        comments.push('<!--', comment.comment.data, '-->');\n        comments.push(hardline);\n        if (comment.emptyLineAfter) {\n            comments.push(hardline);\n        }\n    }\n\n    if (isTopLevel && options.svelteSortOrder !== 'none') {\n        // top level embedded nodes have been moved from their normal position in the\n        // node tree. if there is a comment referring to it, it must be recreated at\n        // the new position.\n        return [...comments, result, hardline];\n    } else {\n        return comments.length ? [...comments, result] : result;\n    }\n}\n\nfunction printJS(\n    node: any,\n    forceSingleQuote: boolean,\n    forceSingleLine: boolean,\n    removeParentheses: boolean,\n    name: string,\n) {\n    if (!node[name] || typeof node[name] !== 'object') {\n        return;\n    }\n    node[name].isJS = true;\n    node[name].forceSingleQuote = forceSingleQuote;\n    node[name].forceSingleLine = forceSingleLine;\n    node[name].removeParentheses = removeParentheses;\n}\n","import { SupportLanguage, Parser, Printer } from 'prettier';\nimport * as prettierPluginBabel from 'prettier/plugins/babel';\nimport { hasPragma, print } from './print';\nimport { ASTNode } from './print/nodes';\nimport { embed, getVisitorKeys } from './embed';\nimport { snipScriptAndStyleTagContent } from './lib/snipTagContent';\nimport { parse } from 'svelte/compiler';\n\nconst babelParser = prettierPluginBabel.parsers.babel;\n\nfunction locStart(node: any) {\n    return node.start;\n}\n\nfunction locEnd(node: any) {\n    return node.end;\n}\n\nexport const languages: Partial<SupportLanguage>[] = [\n    {\n        name: 'svelte',\n        parsers: ['svelte'],\n        extensions: ['.svelte'],\n        vscodeLanguageIds: ['svelte'],\n    },\n];\n\nexport const parsers: Record<string, Parser> = {\n    svelte: {\n        hasPragma,\n        parse: (text) => {\n            try {\n                return <ASTNode>{ ...parse(text), __isRoot: true };\n            } catch (err: any) {\n                if (err.start != null && err.end != null) {\n                    // Prettier expects error objects to have loc.start and loc.end fields.\n                    // Svelte uses start and end directly on the error.\n                    err.loc = {\n                        start: err.start,\n                        end: err.end,\n                    };\n                }\n\n                throw err;\n            }\n        },\n        preprocess: (text, options) => {\n            text = snipScriptAndStyleTagContent(text);\n            text = text.trim();\n            // Prettier sets the preprocessed text as the originalText in case\n            // the Svelte formatter is called directly. In case it's called\n            // as an embedded parser (for example when there's a Svelte code block\n            // inside markdown), the originalText is not updated after preprocessing.\n            // Therefore we do it ourselves here.\n            options.originalText = text;\n            return text;\n        },\n        locStart,\n        locEnd,\n        astFormat: 'svelte-ast',\n    },\n    svelteExpressionParser: {\n        ...babelParser,\n        parse: (text: string, options: any) => {\n            const ast = babelParser.parse(text, options);\n\n            return { ...ast, program: ast.program.body[0].expression };\n        },\n    },\n};\n\nexport const printers: Record<string, Printer> = {\n    'svelte-ast': {\n        print,\n        embed,\n        // @ts-expect-error Prettier's type definitions are wrong\n        getVisitorKeys,\n    },\n};\n\nexport { options } from './options';\n"],"names":["group","hardline","softline","indent","dedent","literalline","printJS","prettierPluginBabel.parsers"],"mappings":"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"}